#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_PLAYERS 4
#define GRID_MIN_SIZE 15
#define GRID_MAX_SIZE 20

typedef struct {
    int x;
    int y;
} Position;

typedef struct {
    Position pos;
    int targetNum;
    int movesPredicted;
    int movesTaken;
} Player;

char grid[GRID_MAX_SIZE][GRID_MAX_SIZE];

void initializeGrid(int gridSize, int numPlayers, Player *players, int numTargets) {
    
    //choisir une taille de grille aléatoire entre 15 et 20
    srand(time(NULL));
    gridSize= rand()%6+15;
    
    
     // Initialiser la grille avec des espaces vides
    for (int i = 0; i < gridSize; i++) {
        for (int j = 0; j < gridSize; j++) {
            grid[i][j] = ' ';
        }
    }

    // Placer les murs autour de la grille
    for (int i = 0; i < gridSize; i++) {
        grid[0][i] = '#';  // Mur supérieur
        grid[i][0] = '#';  // Mur gauche
        grid[gridSize-1][i] = '#';  // Mur inférieur
        grid[i][gridSize-1] = '#';  // Mur droit
    }

    // Placer les joueurs sur des positions aléatoires distinctes
    for (int i = 0; i < numPlayers; i++) {
        int x, y;
        do {
            x = rand() % (gridSize - 2) + 1;
            y = rand() % (gridSize - 2) + 1;
        } while (grid[x][y] != ' '); // Assurer que la position est vide
        players[i].pos.x = x;
        players[i].pos.y = y;
        grid[x][y] = 'P';  // Marquer la position du joueur
    }

    // Placer les cibles (18 cibles numérotées)
    numTargets = 18;
    for (int i = 0; i < numTargets; i++) {
        int x, y;
        do {
            x = rand() % (gridSize - 4) + 2;  // Éviter les bords
            y = rand() % (gridSize - 4) + 2;  // Éviter les bords
        } while (grid[x][y] != ' '); // Assurer que la position est vide
        grid[x][y] = '0' + (i + 1);  // Marquer la position de la cible avec un chiffre
    }

    // Placer les murs autour de chaque cible
    for (int i = 0; i < numTargets; i++) {
        int x = rand() % 2 ? players[i].pos.x - 1 : players[i].pos.x + 1;
        int y = rand() % 2 ? players[i].pos.y - 1 : players[i].pos.y + 1;
        if (grid[x][y] == ' ') grid[x][y] = '#';
        if (grid[x][y] == '#') grid[x][y] = '+';
    }
}



/////////////////////////////////////////////////////////////////////////////////////////////


void displayGrid(int gridSize) {
    system("clear");  // Effacer le terminal (Linux)

    for (int i = 0; i < gridSize; i++) {
        for (int j = 0; j < gridSize; j++) {
            printf("%c ", grid[i][j]);
        }
        printf("\n");
    }
}





/////////////////////////////////////////////////////////////////////////////////////////////




void playGame(int gridSize, int numPlayers, int numRounds) {
    Player players[MAX_PLAYERS];
    int numTargets;
    int roundScores[MAX_PLAYERS] = {0};

    initializeGrid(gridSize, numPlayers, players, numTargets);

    // Boucle de jeu pour chaque manche
    for (int round = 1; round <= numRounds; round++) {
        printf("\nManche %d\n", round);

        // Demander les prédictions de mouvements
        for (int i = 0; i < numPlayers; i++) {
            printf("Joueur %d - Prédiction de coups pour atteindre la cible : ", i+1);
            scanf("%d", &players[i].movesPredicted);
        }

        // Déterminer le joueur avec le moins de coups prédits
        int minPredictedMoves = players[0].movesPredicted;
        int startingPlayer = 0;
        for (int i = 1; i < numPlayers; i++) {
            if (players[i].movesPredicted < minPredictedMoves) {
                minPredictedMoves = players[i].movesPredicted;
                startingPlayer = i;
            }
        }

        printf("Joueur %d commence.\n", startingPlayer + 1);

        // Déplacements des joueurs et calcul des résultats
        for (int i = 0; i < numPlayers; i++) {
            int movesTaken = 0;
            int targetNum = players[i].pos.x > 0 && players[i].pos.y > 0 ? grid[players[i].pos.x - 1][players[i].pos.y] : -1;
            while (targetNum > 0 && players[i].movesTaken <= players[i].movesPredicted) {
                // Afficher la grille
                displayGrid(gridSize);

                // Demander le déplacement au joueur
                char direction;
                printf("Joueur %d - Déplacement (haut/h, bas/b, gauche/g, droite/d) : ", i+1);
                scanf(" %c", &direction);

                // Effectuer le déplacement
                int newX = players[i].pos.x;
                int newY = players[i].pos.y;
                switch (direction) {
                    case 'h': case 'H': newX--; break; // Haut
                    case 'b': case 'B': newX++; break; // Bas
                    case 'g': case 'G': newY--; break; // Gauche
                    case 'd': case 'D': newY++; break; // Droite
                    default: break;
                }

                // Vérifier si le déplacement est valide
                if (grid[newX][newY] == ' ') {
                    grid[players[i].pos.x][players[i].pos.y] = ' '; // Effacer l'ancienne position
                    players[i].pos.x = newX;
                    players[i].pos.y = newY;
                    grid[newX][newY] = 'P'; // Mettre à jour la nouvelle position du joueur
                    movesTaken++;
                }

                // Vérifier s'il atteint la cible
                targetNum = grid[players[i].pos.x - 1][players[i].pos.y];
            }

            // Calcul des résultats
            if (movesTaken == players[i].movesPredicted) {
                roundScores[i] += 2; // Marquer 2 points pour une prédiction correcte
            } else if (movesTaken < players[i].movesPredicted) {
                roundScores[i] -= 1; // Perdre 1 point pour moins de coups que prévu
            } else {
                for (int j = 0; j < numPlayers; j++) {
                    if (i != j) {
                        roundScores[j] += 1; // Marquer 1 point pour les autres joueurs
                    }
                }
            }

            players[i].movesTaken = movesTaken; // Enregistrer le nombre de coups réels
        }
    }

    // Afficher le score final et déterminer le gagnant
    printf("\nScore Final :\n");
    int maxScore = roundScores[0];
    int winner = 0;
    for (int i = 0; i < numPlayers; i++) {
        printf("Joueur %d : %d points\n", i+1, roundScores[i]);
        if (roundScores[i] > maxScore) {
            maxScore = roundScores[i];
            winner = i;
        }
    }
    printf("Le Joueur %d remporte la partie !\n", winner + 1);
}



/////////////////////////////////////////////////////////////////////////////////////////////



int main() {
    int gridSize, numPlayers, numRounds, numTargets;
    Player players;
    

    printf("Bienvenue dans le jeu !\n");
    printf("Entrez le nombre de joueurs (max %d): ", MAX_PLAYERS);
    scanf("%d", &numPlayers);
    printf("Entrez le nombre de manches: ");
    scanf("%d", &numRounds);

    if (numPlayers < 1 || numPlayers > MAX_PLAYERS || numRounds < 1) {
        printf("Entrée invalide. Le jeu va se terminer.\n");
        return 1;
    }
    

    initializeGrid(gridSize, numPlayers, &players, numTargets);
    playGame(gridSize, numPlayers, numRounds);

    return 0;
}
