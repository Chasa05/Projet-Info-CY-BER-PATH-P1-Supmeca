#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_PLAYERS 4
#define GRID_MIN_SIZE 15
#define GRID_MAX_SIZE 20
#define NUM_TARGETS 18

typedef struct {
    int x;
    int y;
} Position;

typedef struct {
    Position pos;
    char target;
    int movesPredicted;
    int movesTaken;
} Player;

char grid[GRID_MAX_SIZE][GRID_MAX_SIZE];
char targets[NUM_TARGETS];

void initializeGrid(int gridSize, int numPlayers, Player *players) {
    // Initialiser la grille avec des espaces vides
    for (int i = 0; i < gridSize; i++) {
        for (int j = 0; j < gridSize; j++) {
            grid[i][j] = ' ';
        }
    }

    // Placer les murs autour de la grille
    for (int i = 0; i < gridSize; i++) {
        grid[0][i] = '#';  // Mur supérieur
        grid[i][0] = '#';  // Mur gauche
        grid[gridSize-1][i] = '#';  // Mur inférieur
        grid[i][gridSize-1] = '#';  // Mur droit
    }

    // Placer les joueurs sur des positions aléatoires distinctes
    for (int i = 0; i < numPlayers; i++) {
        int x, y;
        do {
            x = rand() % (gridSize - 2) + 1;
            y = rand() % (gridSize - 2) + 1;
        } while (grid[x][y] != ' '); // Assurer que la position est vide
        players[i].pos.x = x;
        players[i].pos.y = y;
        grid[x][y] = '1' + i;  // Marquer la position du joueur avec son numéro
    }

    // Initialiser les cibles
    for (int i = 0; i < NUM_TARGETS; i++) {
        targets[i] = 'A' + i;
    }

    // Placer les cibles (18 cibles représentées par des lettres de A à R)
    for (int i = 0; i < NUM_TARGETS; i++) {
        int x, y;
        int validPosition;
        int random;
        do {
            validPosition = 1;
            x = rand() % (gridSize - 4) + 2;  // Éviter les bords
            y = rand() % (gridSize - 4) + 2;  // Éviter les bords

            // Vérifier que la cible n'est pas à côté d'une autre cible
            for (int dx = -1; dx <= 1; dx++) {
                for (int dy = -1; dy <= 1; dy++) {
                    if (grid[x + dx][y + dy] >= 'A' && grid[x + dx][y + dy] <= 'R') {
                        validPosition = 0;
                        break;
                    }
                }
                if (!validPosition) break;
            }
        } while (!validPosition);

        grid[x][y] = targets[i];  // Marquer la position de la cible avec une lettre

        // Placer des murs formant un angle autour de la cible
        
        random = rand () % 4;
        switch (random) {
        case '0' : grid[x][y-1] = '#'; grid[x+1][y] = '#'; break;
        case '1' : grid[x][y-1] = '#'; grid[x-1][y] = '#'; break;
        case '2' : grid[x][y+1] = '#'; grid[x][y+1] = '#'; break;
        case '3' : grid[x][y+1] = '#'; grid[x-1][y] = '#'; break;
        default : break;
        
        }
    }
}



void displayGrid(int gridSize) {
    system("clear");  // Effacer le terminal (Linux)
    for (int i = 0; i < gridSize; i++) {
        for (int j = 0; j < gridSize; j++) {
            printf("%c ", grid[i][j]);
        }
        printf("\n");
    }
}

void movePlayer(Player *player, char direction, int gridSize) {
    int newX = player->pos.x;
    int newY = player->pos.y;
    int dx = 0, dy = 0;

    switch (direction) {
        case 'h': case 'H': dx = -1; break; // Haut
        case 'b': case 'B': dx = 1; break;  // Bas
        case 'g': case 'G': dy = -1; break; // Gauche
        case 'd': case 'D': dy = 1; break;  // Droite
        default: break;
    }

    while (1) {
        int nextX = newX + dx;
        int nextY = newY + dy;

        if (nextX < 0 || nextX >= gridSize || nextY < 0 || nextY >= gridSize || grid[nextX][nextY] != ' ') {
            break;
        }

        newX = nextX;
        newY = nextY;
    }

    // Mettre à jour la grille et la position du joueur
    grid[player->pos.x][player->pos.y] = ' ';
    player->pos.x = newX;
    player->pos.y = newY;
    grid[newX][newY] = '1' + (player - (Player*)player);  // Numéro du joueur
}

void playGame(int gridSize, int numPlayers, int numRounds) {
    Player players[MAX_PLAYERS];
    int roundScores[MAX_PLAYERS] = {0};

     // Boucle de jeu pour chaque manche
    for (int round = 1; round <= numRounds; round++) {
        
        //choisir une taille de grille aléatoire entre 15 et 20
        gridSize = rand() % 6 + 15;
        initializeGrid(gridSize, numPlayers, players);
        displayGrid(gridSize);
        printf("\nManche %d\n", round);
        printf("Taille de la grille : %d\n", gridSize);

        // Assigner une cible à chaque joueur
        for (int i = 0; i < numPlayers; i++) {
            int cible = rand() % 18;
            players[i].target = targets[cible];
            printf("Joueur %d - Votre objectif est la cible %c\n", i+1, players[i].target);
        }

        // Demander les prédictions de mouvements
        for (int i = 0; i < numPlayers; i++) {
            printf("Joueur %d - Prédiction de coups pour atteindre la cible %c : ", i+1, players[i].target);
            scanf("%d", &players[i].movesPredicted);
        }

        // Déterminer le joueur avec le moins de coups prédits
        int minPredictedMoves = players[0].movesPredicted;
        int startingPlayer = 0;
        for (int i = 1; i < numPlayers; i++) {
            if (players[i].movesPredicted < minPredictedMoves) {
                minPredictedMoves = players[i].movesPredicted;
                startingPlayer = i;
            }
        }

        printf("Joueur %d commence.\n", startingPlayer + 1);

        // Déplacements des joueurs et calcul des résultats
        for (int i = 0; i < numPlayers; i++) {
            int movesTaken = 0;
            int targetReached = 0;

            while (movesTaken < players[i].movesPredicted) {
                // Afficher la grille
                displayGrid(gridSize);

                // Demander le déplacement au joueur
                char direction;
                printf("Joueur %d - Déplacement (haut/h, bas/b, gauche/g, droite/d) : ", i+1);
                scanf(" %c", &direction);

                // Déplacer le joueur en ligne droite
                movePlayer(&players[i], direction, gridSize);
                movesTaken++;

                // Vérifier s'il atteint la cible
                if (grid[players[i].pos.x][players[i].pos.y] == players[i].target) {
                    targetReached = 1;
                    grid[players[i].pos.x][players[i].pos.y] = ' '; // Effacer la cible atteinte
                    break;
                }
            }

            // Calcul des résultats
            players[i].movesTaken = movesTaken; // Enregistrer le nombre de coups réels

            if (targetReached && movesTaken == players[i].movesPredicted) {
                roundScores[i] += 2; // Marquer 2 points pour une prédiction correcte
            } else if (movesTaken < players[i].movesPredicted) {
                roundScores[i] -= 1; // Perdre 1 point pour moins de coups que prévu
            } else {
                for (int j = 0; j < numPlayers; j++) {
                    if (i != j) {
                        roundScores[j] += 1; // Marquer 1 point pour les autres joueurs
                    }
                }
            }
        }
    }

    // Afficher le score final et déterminer le gagnant
    printf("\nScore Final :\n");
    int maxScore = roundScores[0];
    int winner = 0;
    for (int i = 0; i < numPlayers; i++) {
        printf("Joueur %d : %d points\n", i+1, roundScores[i]);
        if (roundScores[i] > maxScore) {
            maxScore = roundScores[i];
            winner = i;
        }
    }
    printf("Le Joueur %d remporte la partie !\n", winner + 1);
}

int main() {
    int gridSize, numPlayers, numRounds;
    
    srand(time(NULL));
    //choisir une taille de grille aléatoire entre 15 et 20
    gridSize = rand() % 6 + 15;
    
    printf("Bienvenue dans le jeu !\n");
    printf("Entrez le nombre de joueurs (max %d): ", MAX_PLAYERS);
    scanf("%d", &numPlayers);
    printf("Entrez le nombre de manches: ");
    scanf("%d", &numRounds);

    if (numPlayers < 1 || numPlayers > MAX_PLAYERS || numRounds < 1) {
        printf("Entrée invalide. Le jeu va se terminer.\n");
        return 1;
    }

    playGame(gridSize, numPlayers, numRounds);

    return 0;
}
